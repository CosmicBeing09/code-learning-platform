{
  "factorial": {
    "java": "public class Factorial {\n    public static int factorial(int n) {\n        if (n == 0) {\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(factorial(5)); // Output should be 120\n    }\n}",
    "java_error_1": "public class Factorial {\n    public static int factorial(int n) {\n        // Missing base case\n        return n * factorial(n - 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(factorial(5)); // This will cause a StackOverflowError\n    }\n}",
    "java_error_2": "public class Factorial {\n    public static int factorial(int n) {\n        if (n == 1) { // Incorrect base case condition\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(factorial(0)); // This will cause a StackOverflowError\n    }\n}",
    "python": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nprint(factorial(5))  # Output should be 120",
    "python_error_1": "def factorial(n):\n    # Missing base case\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # This will cause a RecursionError: maximum recursion depth exceeded",
    "python_error_2": "def factorial(n):\n    if n == 1:  # Incorrect base case condition\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nprint(factorial(0))  # This will cause a RecursionError: maximum recursion depth exceeded",
    "javascript": "function factorial(n) {\n    if (n === 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nconsole.log(factorial(5)); // Output should be 120",
    "javascript_error_1": "function factorial(n) {\n    // Missing base case\n    return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5)); // This will cause a RangeError: Maximum call stack size exceeded",
    "javascript_error_2": "function factorial(n) {\n    if (n === 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nconsole.log(factorial(0)); // This will cause a RangeError: Maximum call stack size exceeded",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint factorial(int n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nint main() {\n    cout << factorial(5) << endl; // Output should be 120\n    return 0;\n}",
    "cpp_error_1": "#include <iostream>\nusing namespace std;\n\nint factorial(int n) {\n    // Missing base case\n    return n * factorial(n - 1);\n}\n\nint main() {\n    cout << factorial(5) << endl; // This will cause a stack overflow\n    return 0;\n}",
    "cpp_error_2": "#include <iostream>\nusing namespace std;\n\nint factorial(int n) {\n    if (n == 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nint main() {\n    cout << factorial(0) << endl; // This will cause a stack overflow\n    return 0;\n}",
    "typescript": "function factorial(n: number): number {\n    if (n === 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nconsole.log(factorial(5)); // Output should be 120",
    "typescript_error_1": "function factorial(n: number): number {\n    // Missing base case\n    return n * factorial(n - 1);\n}\n\nconsole.log(factorial(5)); // This will cause a RangeError: Maximum call stack size exceeded",
    "typescript_error_2": "function factorial(n: number): number {\n    if (n === 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nconsole.log(factorial(0)); // This will cause a RangeError: Maximum call stack size exceeded",
    "ruby": "def factorial(n)\n    return 1 if n == 0\n    n * factorial(n - 1)\nend\n\nputs factorial(5) # Output should be 120",
    "ruby_error_1": "def factorial(n)\n    # Missing base case\n    n * factorial(n - 1)\nend\n\nputs factorial(5) # This will cause a SystemStackError: stack level too deep",
    "ruby_error_2": "def factorial(n)\n    return 1 if n == 1 # Incorrect base case condition\n    n * factorial(n - 1)\nend\n\nputs factorial(0) # This will cause a SystemStackError: stack level too deep",
    "go": "package main\nimport \"fmt\"\n\nfunc factorial(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return n * factorial(n - 1)\n}\n\nfunc main() {\n    fmt.Println(factorial(5)) // Output should be 120\n}",
    "go_error_1": "package main\nimport \"fmt\"\n\nfunc factorial(n int) int {\n    // Missing base case\n    return n * factorial(n - 1)\n}\n\nfunc main() {\n    fmt.Println(factorial(5)) // This will cause a runtime error: goroutine stack exceeds 1000000000-byte limit\n}",
    "go_error_2": "package main\nimport \"fmt\"\n\nfunc factorial(n int) int {\n    if n == 1 { // Incorrect base case condition\n        return 1\n    }\n    return n * factorial(n - 1)\n}\n\nfunc main() {\n    fmt.Println(factorial(0)) // This will cause a runtime error: goroutine stack exceeds 1000000000-byte limit\n}",
    "php": "<?php\nfunction factorial($n) {\n    if ($n == 0) {\n        return 1;\n    } else {\n        return $n * factorial($n - 1);\n    }\n}\n\necho factorial(5); // Output should be 120\n?>",
    "php_error_1": "<?php\nfunction factorial($n) {\n    // Missing base case\n    return $n * factorial($n - 1);\n}\n\necho factorial(5); // This will cause a Fatal error: Maximum function nesting level of '100' reached, aborting!\n?>",
    "php_error_2": "<?php\nfunction factorial($n) {\n    if ($n == 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return $n * factorial($n - 1);\n    }\n}\n\necho factorial(0); // This will cause a Fatal error: Maximum function nesting level of '100' reached, aborting!\n?>",
    "swift": "func factorial(_ n: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else {\n        return n * factorial(n - 1)\n    }\n}\n\nprint(factorial(5)) // Output should be 120",
    "swift_error_1": "func factorial(_ n: Int) -> Int {\n    // Missing base case\n    return n * factorial(n - 1)\n}\n\nprint(factorial(5)) // This will cause a fatal error: Stack overflow\n",
    "swift_error_2": "func factorial(_ n: Int) -> Int {\n    if n == 1 { // Incorrect base case condition\n        return 1\n    } else {\n        return n * factorial(n - 1)\n    }\n}\n\nprint(factorial(0)) // This will cause a fatal error: Stack overflow\n",
    "rust": "fn factorial(n: u32) -> u32 {\n    if n == 0 {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nfn main() {\n    println!(\"{}\", factorial(5)); // Output should be 120\n}",
    "rust_error_1": "fn factorial(n: u32) -> u32 {\n    // Missing base case\n    return n * factorial(n - 1);\n}\n\nfn main() {\n    println!(\"{}\", factorial(5)); // This will cause a stack overflow\n}",
    "rust_error_2": "fn factorial(n: u32) -> u32 {\n    if n == 1 { // Incorrect base case condition\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\nfn main() {\n    println!(\"{}\", factorial(0)); // This will cause a stack overflow\n}"
  },
  "fibonacci": {
    "java": "public class Fibonacci {\n    public static int fibonacci(int n) {\n        if (n <= 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fibonacci(5)); // Output should be 5\n    }\n}",
    "java_error_1": "public class Fibonacci {\n    public static int fibonacci(int n) {\n        // Missing base case\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fibonacci(5)); // This will cause a StackOverflowError\n    }\n}",
    "java_error_2": "public class Fibonacci {\n    public static int fibonacci(int n) {\n        if (n == 1) { // Incorrect base case condition\n            return 1;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(fibonacci(0)); // This will cause a StackOverflowError\n    }\n}",
    "python": "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(5))  # Output should be 5",
    "python_error_1": "def fibonacci(n):\n    if n < 0:  # Incorrect base case\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(5))  # This may cause incorrect results",
    "python_error_2": "def fibonacci(n):\n    # Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(5))  # This will cause a RecursionError: maximum recursion depth exceeded",
    "javascript": "function fibonacci(n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n === 1) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nconsole.log(fibonacci(5)); // Output should be 5",
    "javascript_error_1": "function fibonacci(n) {\n    // Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconsole.log(fibonacci(5)); // This will cause a RangeError: Maximum call stack size exceeded",
    "javascript_error_2": "function fibonacci(n) {\n    if (n === 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nconsole.log(fibonacci(0)); // This will cause a RangeError: Maximum call stack size exceeded",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint fibonacci(int n) {\n    if (n <= 0) {\n        return 0;\n    } else if (n == 1) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nint main() {\n    cout << fibonacci(5) << endl; // Output should be 5\n    return 0;\n}",
    "cpp_error_1": "#include <iostream>\nusing namespace std;\n\nint fibonacci(int n) {\n    // Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nint main() {\n    cout << fibonacci(5) << endl; // This will cause a stack overflow\n    return 0;\n}",
    "cpp_error_2": "#include <iostream>\nusing namespace std;\n\nint fibonacci(int n) {\n    if (n == 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nint main() {\n    cout << fibonacci(0) << endl; // This will cause a stack overflow\n    return 0;\n}",
    "typescript": "function fibonacci(n: number): number {\n    if (n <= 0) {\n        return 0;\n    } else if (n === 1) {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nconsole.log(fibonacci(5)); // Output should be 5",
    "typescript_error_1": "function fibonacci(n: number): number {\n    // Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconsole.log(fibonacci(5)); // This will cause a RangeError: Maximum call stack size exceeded",
    "typescript_error_2": "function fibonacci(n: number): number {\n    if (n === 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nconsole.log(fibonacci(0)); // This will cause a RangeError: Maximum call stack size exceeded",
    "ruby": "def fibonacci(n)\n    return 0 if n <= 0\n    return 1 if n == 1\n    fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nputs fibonacci(5) # Output should be 5",
    "ruby_error_1": "def fibonacci(n)\n    # Missing base case\n    fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nputs fibonacci(5) # This will cause a SystemStackError: stack level too deep",
    "ruby_error_2": "def fibonacci(n)\n    return 1 if n == 1 # Incorrect base case condition\n    fibonacci(n - 1) + fibonacci(n - 2)\nend\n\nputs fibonacci(0) # This will cause a SystemStackError: stack level too deep",
    "go": "package main\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nfunc main() {\n    fmt.Println(fibonacci(5)) // Output should be 5\n}",
    "go_error_1": "package main\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    // Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nfunc main() {\n    fmt.Println(fibonacci(5)) // This will cause a runtime error: goroutine stack exceeds 1000000000-byte limit\n}",
    "go_error_2": "package main\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    if n == 1 { // Incorrect base case condition\n        return 1\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nfunc main() {\n    fmt.Println(fibonacci(0)) // This will cause a runtime error: goroutine stack exceeds 1000000000-byte limit\n}",
    "php": "<?php\nfunction fibonacci($n) {\n    if ($n <= 0) {\n        return 0;\n    } else if ($n == 1) {\n        return 1;\n    } else {\n        return fibonacci($n - 1) + fibonacci($n - 2);\n    }\n}\n\necho fibonacci(5); // Output should be 5\n?>",
    "php_error_1": "<?php\nfunction fibonacci($n) {\n    // Missing base case\n    return fibonacci($n - 1) + fibonacci($n - 2);\n}\n\necho fibonacci(5); // This will cause a Fatal error: Maximum function nesting level of '100' reached, aborting!\n?>",
    "php_error_2": "<?php\nfunction fibonacci($n) {\n    if ($n == 1) { // Incorrect base case condition\n        return 1;\n    } else {\n        return fibonacci($n - 1) + fibonacci($n - 2);\n    }\n}\n\necho fibonacci(0); // This will cause a Fatal error: Maximum function nesting level of '100' reached, aborting!\n?>",
    "swift": "func fibonacci(_ n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\nprint(fibonacci(5)) // Output should be 5",
    "swift_error_1": "func fibonacci(_ n: Int) -> Int {\n    // Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nprint(fibonacci(5)) // This will cause a fatal error: Stack overflow\n",
    "swift_error_2": "func fibonacci(_ n: Int) -> Int {\n    if n == 1 { // Incorrect base case condition\n        return 1\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\nprint(fibonacci(0)) // This will cause a fatal error: Stack overflow\n",
    "rust": "fn fibonacci(n: i32) -> i32 {\n    if n <= 0 {\n        return 0;\n    } else if n == 1 {\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nfn main() {\n    println!(\"{}\", fibonacci(5)); // Output should be 5\n}",
    "rust_error_1": "fn fibonacci(n: i32) -> i32 {\n    // Missing base case\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nfn main() {\n    println!(\"{}\", fibonacci(5)); // This will cause a stack overflow\n}",
    "rust_error_2": "fn fibonacci(n: i32) -> i32 {\n    if n == 1 { // Incorrect base case condition\n        return 1;\n    } else {\n        return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n\nfn main() {\n    println!(\"{}\", fibonacci(0)); // This will cause a stack overflow\n}"
  },
  "is_palindrome": {
    "java": "public class Palindrome {\n    public static boolean isPalindrome(String s) {\n        return s.equals(new StringBuilder(s).reverse().toString());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(\"racecar\")); // Output should be true\n    }\n}",
    "java_error_1": "public class Palindrome {\n    public static boolean isPalindrome(String s) {\n        // Missing reverse\n        return s.equals(s);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(\"racecar\")); // This will always return true\n    }\n}",
    "java_error_2": "public class Palindrome {\n    public static boolean isPalindrome(String s) {\n        // Incorrect comparison\n        return s == new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(\"racecar\")); // This will always return false\n    }\n}",
    "python": "def is_palindrome(s):\n    return s == s[::-1]\n\nprint(is_palindrome(\"racecar\"))  # Output should be true",
    "python_error_1": "def is_palindrome(s):\n    return s is s[::-1]  # Incorrect comparison\n\nprint(is_palindrome(\"racecar\"))  # This will always return False",
    "python_error_2": "def is_palindrome(s):\n    return s == s  # Missing reverse\n\nprint(is_palindrome(\"racecar\"))  # This will always return True",
    "javascript": "function isPalindrome(s) {\n    return s === s.split('').reverse().join('');\n}\n\nconsole.log(isPalindrome(\"racecar\")); // Output should be true",
    "javascript_error_1": "function isPalindrome(s) {\n    // Missing reverse\n    return s === s;\n}\n\nconsole.log(isPalindrome(\"racecar\")); // This will always return true",
    "javascript_error_2": "function isPalindrome(s) {\n    // Incorrect comparison\n    return s == s.split('').reverse().join('');\n}\n\nconsole.log(isPalindrome(\"racecar\")); // This will always return false",
    "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nbool isPalindrome(string s) {\n    string rev = s;\n    reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nint main() {\n    cout << boolalpha << isPalindrome(\"racecar\") << endl; // Output should be true\n    return 0;\n}",
    "cpp_error_1": "#include <iostream>\nusing namespace std;\n\nbool isPalindrome(string s) {\n    // Missing reverse\n    return s == s;\n}\n\nint main() {\n    cout << boolalpha << isPalindrome(\"racecar\") << endl; // This will always return true\n    return 0;\n}",
    "cpp_error_2": "#include <iostream>\nusing namespace std;\n\nbool isPalindrome(string s) {\n    // Incorrect comparison\n    return s == string(s.rbegin(), s.rend());\n}\n\nint main() {\n    cout << boolalpha << isPalindrome(\"racecar\") << endl; // This will always return false\n    return 0;\n}",
    "typescript": "function isPalindrome(s: string): boolean {\n    return s === s.split('').reverse().join('');\n}\n\nconsole.log(isPalindrome(\"racecar\")); // Output should be true",
    "typescript_error_1": "function isPalindrome(s: string): boolean {\n    // Missing reverse\n    return s === s;\n}\n\nconsole.log(isPalindrome(\"racecar\")); // This will always return true",
    "typescript_error_2": "function isPalindrome(s: string): boolean {\n    // Incorrect comparison\n    return s == s.split('').reverse().join('');\n}\n\nconsole.log(isPalindrome(\"racecar\")); // This will always return false",
    "ruby": "def is_palindrome(s)\n    s == s.reverse\nend\n\nputs is_palindrome(\"racecar\") # Output should be true",
    "ruby_error_1": "def is_palindrome(s)\n    # Missing reverse\n    s == s\nend\n\nputs is_palindrome(\"racecar\") # This will always return true",
    "ruby_error_2": "def is_palindrome(s)\n    # Incorrect comparison\n    s.equal?(s.reverse)\nend\n\nputs is_palindrome(\"racecar\") # This will always return false",
    "go": "package main\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc isPalindrome(s string) bool {\n    rev := reverse(s)\n    return s == rev\n}\n\nfunc reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}\n\nfunc main() {\n    fmt.Println(isPalindrome(\"racecar\")) // Output should be true\n}",
    "go_error_1": "package main\nimport \"fmt\"\n\nfunc isPalindrome(s string) bool {\n    // Missing reverse\n    return s == s\n}\n\nfunc main() {\n    fmt.Println(isPalindrome(\"racecar\")) // This will always return true\n}",
    "go_error_2": "package main\nimport \"fmt\"\n\nfunc isPalindrome(s string) bool {\n    // Incorrect comparison\n    return s == string([]rune(s))\n}\n\nfunc main() {\n    fmt.Println(isPalindrome(\"racecar\")) // This will always return false\n}",
    "php": "<?php\nfunction isPalindrome($s) {\n    return $s === strrev($s);\n}\n\necho isPalindrome(\"racecar\") ? 'true' : 'false'; // Output should be true\n?>",
    "php_error_1": "<?php\nfunction isPalindrome($s) {\n    // Missing reverse\n    return $s === $s;\n}\n\necho isPalindrome(\"racecar\") ? 'true' : 'false'; // This will always return true\n?>",
    "php_error_2": "<?php\nfunction isPalindrome($s) {\n    // Incorrect comparison\n    return $s == strrev($s);\n}\n\necho isPalindrome(\"racecar\") ? 'true' : 'false'; // This will always return false\n?>",
    "swift": "func isPalindrome(_ s: String) -> Bool {\n    return s == String(s.reversed())\n}\n\nprint(isPalindrome(\"racecar\")) // Output should be true",
    "swift_error_1": "func isPalindrome(_ s: String) -> Bool {\n    // Missing reverse\n    return s == s\n}\n\nprint(isPalindrome(\"racecar\")) // This will always return true",
    "swift_error_2": "func isPalindrome(_ s: String) -> Bool {\n    // Incorrect comparison\n    return s == String(s)\n}\n\nprint(isPalindrome(\"racecar\")) // This will always return false",
    "rust": "fn is_palindrome(s: &str) -> bool {\n    s == s.chars().rev().collect::<String>()\n}\n\nfn main() {\n    println!(\"{}\", is_palindrome(\"racecar\")); // Output should be true\n}",
    "rust_error_1": "fn is_palindrome(s: &str) -> bool {\n    // Missing reverse\n    s == s\n}\n\nfn main() {\n    println!(\"{}\", is_palindrome(\"racecar\")); // This will always return true\n}",
    "rust_error_2": "fn is_palindrome(s: &str) -> bool {\n    // Incorrect comparison\n    s == s.chars().collect::<String>()\n}\n\nfn main() {\n    println!(\"{}\", is_palindrome(\"racecar\")); // This will always return false\n}"
  },
  "is_prime": {
    "java": "public class Prime {\n    public static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPrime(7)); // Output should be true\n    }\n}",
    "java_error_1": "public class Prime {\n    public static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        // Missing return statement\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPrime(7)); // This will cause a compilation error\n    }\n}",
    "java_error_2": "public class Prime {\n    public static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isPrime(4)); // This will return true for non-prime numbers\n    }\n}",
    "python": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # Output should be true",
    "python_error_1": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # This may cause incorrect results",
    "python_error_2": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    # Missing return statement\n\nprint(is_prime(7))  # This will return None",
    "javascript": "function isPrime(n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(isPrime(7)); // Output should be true",
    "javascript_error_1": "function isPrime(n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    // Missing return statement\n}\n\nconsole.log(isPrime(7)); // This will cause a runtime error",
    "javascript_error_2": "function isPrime(n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(isPrime(4)); // This will return true for non-prime numbers",
    "cpp": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cout << boolalpha << isPrime(7) << endl; // Output should be true\n    return 0;\n}",
    "cpp_error_1": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    // Missing return statement\n}\n\nint main() {\n    cout << boolalpha << isPrime(7) << endl; // This will cause a compilation error\n    return 0;\n}",
    "cpp_error_2": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cout << boolalpha << isPrime(4) << endl; // This will return true for non-prime numbers\n    return 0;\n}",
    "typescript": "function isPrime(n: number): boolean {\n    if (n <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(isPrime(7)); // Output should be true",
    "typescript_error_1": "function isPrime(n: number): boolean {\n    if (n <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    // Missing return statement\n}\n\nconsole.log(isPrime(7)); // This will cause a runtime error",
    "typescript_error_2": "function isPrime(n: number): boolean {\n    if (n <= 1) {\n        return false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconsole.log(isPrime(4)); // This will return true for non-prime numbers",
    "ruby": "def is_prime(n)\n    return false if n <= 1\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\nputs is_prime(7) # Output should be true",
    "ruby_error_1": "def is_prime(n)\n    return false if n <= 1\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    # Missing return statement\nend\n\nputs is_prime(7) # This will cause a runtime error",
    "ruby_error_2": "def is_prime(n)\n    return false if n <= 1\n    (2..Math.sqrt(n)).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\nputs is_prime(4) # This will return true for non-prime numbers",
    "go": "package main\nimport \"fmt\"\nimport \"math\"\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(isPrime(7)) // Output should be true\n}",
    "go_error_1": "package main\nimport \"fmt\"\nimport \"math\"\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n % i == 0 {\n            return false\n        }\n    }\n    // Missing return statement\n}\n\nfunc main() {\n    fmt.Println(isPrime(7)) // This will cause a runtime error\n}",
    "go_error_2": "package main\nimport \"fmt\"\nimport \"math\"\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(isPrime(4)) // This will return true for non-prime numbers\n}",
    "php": "<?php\nfunction isPrime($n) {\n    if ($n <= 1) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\necho isPrime(7) ? 'true' : 'false'; // Output should be true\n?>",
    "php_error_1": "<?php\nfunction isPrime($n) {\n    if ($n <= 1) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    // Missing return statement\n}\n\necho isPrime(7) ? 'true' : 'false'; // This will cause a runtime error\n?>",
    "php_error_2": "<?php\nfunction isPrime($n) {\n    if ($n <= 1) {\n        return false;\n    }\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\necho isPrime(4) ? 'true' : 'false'; // This will return true for non-prime numbers\n?>",
    "swift": "func isPrime(_ n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    for i in 2...Int(Double(n).squareRoot()) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nprint(isPrime(7)) // Output should be true",
    "swift_error_1": "func isPrime(_ n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    for i in 2...Int(Double(n).squareRoot()) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    // Missing return statement\n}\n\nprint(isPrime(7)) // This will cause a runtime error",
    "swift_error_2": "func isPrime(_ n: Int) -> Bool {\n    if n <= 1 {\n        return false\n    }\n    for i in 2...Int(Double(n).squareRoot()) {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nprint(isPrime(4)) // This will return true for non-prime numbers",
    "rust": "fn is_prime(n: i32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_prime(7)); // Output should be true\n}",
    "rust_error_1": "fn is_prime(n: i32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    // Missing return statement\n}\n\nfn main() {\n    println!(\"{}\", is_prime(7)); // This will cause a compilation error\n}",
    "rust_error_2": "fn is_prime(n: i32) -> bool {\n    if n <= 1 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    println!(\"{}\", is_prime(4)); // This will return true for non-prime numbers\n}"
  },
  "gcd": {
    "java": "public class GCD {\n    public static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(gcd(48, 18)); // Output should be 6\n    }\n}",
    "java_error_1": "public class GCD {\n    public static int gcd(int a, int b) {\n        while (b == 0) { // Incorrect loop condition\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(gcd(48, 18)); // This will cause an infinite loop\n    }\n}",
    "java_error_2": "public class GCD {\n    public static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a / b; // Incorrect modulus operation\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(gcd(48, 18)); // This will cause incorrect results\n    }\n}",
    "python": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\nprint(gcd(48, 18))  # Output should be 6",
    "python_error_1": "def gcd(a, b):\n    while b == 0:  # Incorrect loop condition\n        a, b = b, a % b\n    return a\n\nprint(gcd(48, 18))  # This will cause an infinite loop",
    "python_error_2": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a // b  # Incorrect modulus operation\n    return a\n\nprint(gcd(48, 18))  # This will cause incorrect results",
    "javascript": "function gcd(a, b) {\n    while (b !== 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nconsole.log(gcd(48, 18)); // Output should be 6",
    "javascript_error_1": "function gcd(a, b) {\n    while (b === 0) { // Incorrect loop condition\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nconsole.log(gcd(48, 18)); // This will cause an infinite loop",
    "javascript_error_2": "function gcd(a, b) {\n    while (b !== 0) {\n        let temp = b;\n        b = a / b; // Incorrect modulus operation\n        a = temp;\n    }\n    return a;\n}\n\nconsole.log(gcd(48, 18)); // This will cause incorrect results",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    cout << gcd(48, 18) << endl; // Output should be 6\n    return 0;\n}",
    "cpp_error_1": "#include <iostream>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b == 0) { // Incorrect loop condition\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    cout << gcd(48, 18) << endl; // This will cause an infinite loop\n    return 0;\n}",
    "cpp_error_2": "#include <iostream>\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a / b; // Incorrect modulus operation\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    cout << gcd(48, 18) << endl; // This will cause incorrect results\n    return 0;\n}",
    "typescript": "function gcd(a: number, b: number): number {\n    while (b !== 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nconsole.log(gcd(48, 18)); // Output should be 6",
    "typescript_error_1": "function gcd(a: number, b: number): number {\n    while (b === 0) { // Incorrect loop condition\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nconsole.log(gcd(48, 18)); // This will cause an infinite loop",
    "typescript_error_2": "function gcd(a: number, b: number): number {\n    while (b !== 0) {\n        let temp = b;\n        b = a / b; // Incorrect modulus operation\n        a = temp;\n    }\n    return a;\n}\n\nconsole.log(gcd(48, 18)); // This will cause incorrect results",
    "ruby": "def gcd(a, b)\n    while b != 0\n        a, b = b, a % b\n    end\n    a\nend\n\nputs gcd(48, 18) # Output should be 6",
    "ruby_error_1": "def gcd(a, b)\n    while b == 0\n        a, b = b, a % b\n    end\n    a\nend\n\nputs gcd(48, 18) # This will cause an infinite loop",
    "ruby_error_2": "def gcd(a, b)\n    while b != 0\n        a, b = b, a / b\n    end\n    a\nend\n\nputs gcd(48, 18) # This will cause incorrect results",
    "go": "package main\nimport \"fmt\"\n\nfunc gcd(a, b int) int {\n    for b != 0 {\n        a, b = b, a % b\n    }\n    return a\n}\n\nfunc main() {\n    fmt.Println(gcd(48, 18)) // Output should be 6\n}",
    "go_error_1": "package main\nimport \"fmt\"\n\nfunc gcd(a, b int) int {\n    for b == 0 {\n        a, b = b, a % b\n    }\n    return a\n}\n\nfunc main() {\n    fmt.Println(gcd(48, 18)) // This will cause an infinite loop\n}",
    "go_error_2": "package main\nimport \"fmt\"\n\nfunc gcd(a, b int) int {\n    for b != 0 {\n        a, b = b, a / b\n    }\n    return a\n}\n\nfunc main() {\n    fmt.Println(gcd(48, 18)) // This will cause incorrect results\n}",
    "php": "<?php\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $temp = $b;\n        $b = $a % $b;\n        $a = $temp;\n    }\n    return $a;\n}\n\necho gcd(48, 18); // Output should be 6\n?>",
    "php_error_1": "<?php\nfunction gcd($a, $b) {\n    while ($b == 0) {\n        $temp = $b;\n        $b = $a % $b;\n        $a = $temp;\n    }\n    return $a;\n}\n\necho gcd(48, 18); // This will cause an infinite loop\n?>",
    "php_error_2": "<?php\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $temp = $b;\n        $b = $a / $b;\n        $a = $temp;\n    }\n    return $a;\n}\n\necho gcd(48, 18); // This will cause incorrect results\n?>",
    "swift": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\nprint(gcd(48, 18)) // Output should be 6",
    "swift_error_1": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b == 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\nprint(gcd(48, 18)) // This will cause an infinite loop",
    "swift_error_2": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        let temp = b\n        b = a / b\n        a = temp\n    }\n    return a\n}\n\nprint(gcd(48, 18)) // This will cause incorrect results",
    "rust": "fn gcd(mut a: i32, mut b: i32) -> i32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\nfn main() {\n    println!(\"{}\", gcd(48, 18)); // Output should be 6\n}",
    "rust_error_1": "fn gcd(mut a: i32, mut b: i32) -> i32 {\n    while b == 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\nfn main() {\n    println!(\"{}\", gcd(48, 18)); // This will cause an infinite loop\n}",
    "rust_error_2": "fn gcd(mut a: i32, mut b: i32) -> i32 {\n    while b != 0 {\n        let temp = b;\n        b = a / b;\n        a = temp;\n    }\n    a\n}\n\nfn main() {\n    println!(\"{}\", gcd(48, 18)); // This will cause incorrect results\n}"
  }
}
